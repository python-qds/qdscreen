{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"qdscreen","text":"<p>Remove redundancy in your categorical variables and increase your models performance.</p> <p> </p> <p> </p> <p><code>qdscreen</code> provides a python implementation of the Quasi-determinism screening algorithm (also known as <code>qds-BNSL</code>) from T.Rahier's PhD thesis, 2018.</p> <p>Most data scientists are familiar with the concept of correlation between continuous variables. This concept extends to categorical variables, and is known as functional dependency in the field of relational databases mining. We also name it determinism in the context of Machine Learning and Statistics, to indicate that when a random variable <code>X</code> is known then the value of another variable <code>Y</code> is determined with absolute certainty. \"Quasi-\"determinism is an extension of this concept to handle noise or extremely rare cases in data.</p> <p><code>qdscreen</code> is able to detect and remove (quasi-)deterministic relationships in a dataset:</p> <ul> <li> <p>either as a preprocessing step in any general-purpose data science pipeline</p> </li> <li> <p>or as an accelerator of a Bayesian Network Structure Learning method such as <code>pyGOBN</code></p> </li> </ul>"},{"location":"#installing","title":"Installing","text":"<pre><code>&gt; pip install qdscreen\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#1-remove-correlated-variables","title":"1. Remove correlated variables","text":"<p>See this example.</p>"},{"location":"#2-learn-a-bayesian-network-structure","title":"2. Learn a Bayesian Network structure","text":"<p>TODO see #6.</p>"},{"location":"#main-features-benefits","title":"Main features / benefits","text":"<ul> <li> <p>A feature selection algorithm able to eliminate quasi-deterministic relationships</p> <ul> <li>a base version compliant with numpy and pandas datasets</li> <li>a scikit-learn compliant version (numpy only)</li> </ul> </li> <li> <p>An accelerator for Bayesian Network Structure Learning tasks</p> </li> </ul>"},{"location":"#see-also","title":"See Also","text":"<ul> <li> <p>Bayesian Network libraries in python: </p> <ul> <li><code>pyGOBN</code> (MIT license)</li> <li><code>pgmpy</code> (MIT license)</li> <li><code>pomegranate</code> (MIT license)</li> <li><code>bayespy</code> (MIT license)</li> </ul> </li> <li> <p>Functional dependencies libraries in python:</p> <ul> <li><code>fd_miner</code>, an algorithm that was used in this paper. The repository contains a list of reference datasets too.</li> <li><code>FDTool</code> a python 2 algorithm to mine for functional dependencies, equivalences and candidate keys. From this paper.</li> <li><code>functional-dependencies</code></li> <li><code>functional-dependency-finder</code> connects to a MySQL db and finds functional dependencies.</li> </ul> </li> <li> <p>Other libs for probabilistic inference:</p> <ul> <li><code>pyjags</code> (GPLv2 license)</li> <li><code>edward</code> (Apache License, Version 2.0)</li> </ul> </li> <li> <p>Stackoverflow discussions:</p> <ul> <li>detecting normal forms</li> <li>canonical cover</li> </ul> </li> </ul>"},{"location":"#others","title":"Others","text":"<p>Do you like this library ? You might also like smarie's other python libraries </p>"},{"location":"#want-to-contribute","title":"Want to contribute ?","text":"<p>Details on the github page: https://github.com/python-qds/qdscreen</p>"},{"location":"api_reference/","title":"API reference","text":"<p>In general, using <code>help(symbol)</code> is the recommended way to get the latest documentation. In addition, this page provides an overview of the various elements in this package.</p>"},{"location":"api_reference/#main-symbols","title":"Main symbols","text":""},{"location":"api_reference/#qd_screen","title":"<code>qd_screen</code>","text":"<pre><code>def qd_screen(X: Union[pd.DataFrame, np.ndarray],\n              absolute_eps: float = None,\n              relative_eps: float = None,\n              keep_stats: bool = False\n              ) -&gt; QDForest\n</code></pre> <p>Finds the (quasi-)deterministic relationships (functional dependencies) between the variables in <code>X</code>, and returns a <code>QDForest</code> object representing the forest of (quasi-)deterministic trees. This object can then be used to fit a feature selection model or to learn a Bayesian Network structure.</p> <p>By default only deterministic relationships are detected. Quasi-determinism can be enabled by setting either an threshold on conditional entropies (<code>absolute_eps</code>) or on relative conditional entropies (<code>relative_eps</code>). Only one of them should be set.</p> <p>By default (<code>keep_stats=False</code>) the entropies tables are not preserved once the forest has been created. If you wish to keep them available, set <code>keep_stats=True</code>. The entropies tables are then available in the <code>&lt;QDForest&gt;.stats</code> attribute, and threshold analysis methods such as <code>&lt;QDForest&gt;.get_entropies_table(...)</code> and <code>&lt;QDForest&gt;.plot_increasing_entropies()</code> become available.</p> <p>Parameters:</p> <ul> <li> <p><code>X</code>: the dataset as a pandas DataFrame or a numpy array. Columns represent the features to compare.</p> </li> <li> <p><code>absolute_eps</code>: Absolute entropy threshold. Any feature <code>Y</code> that can be predicted from another feature <code>X</code> in a quasi-deterministic way, that is, where conditional entropy <code>H(Y|X) &lt;= absolute_eps</code>, will be removed. The default value is <code>0</code> and corresponds to removing deterministic relationships only.</p> </li> <li> <p><code>relative_eps</code>: Relative entropy threshold. Any feature <code>Y</code> that can be predicted from another feature <code>X</code> in a quasi-deterministic way, that is, where relative conditional entropy <code>H(Y|X)/H(Y) &lt;= relative_eps</code> (a value between <code>0</code> and <code>1</code>), will be removed. Only one of <code>absolute_eps</code> or <code>relative_eps</code> should be provided.</p> </li> <li> <p><code>keep_stats</code>: a boolean indicating if the various entropies tables computed in the process should be kept in memory in the resulting forest object (<code>&lt;QDForest&gt;.stats</code>), for further analysis. By default this is <code>False</code>. </p> </li> </ul>"},{"location":"api_reference/#qdforest","title":"<code>QDForest</code>","text":"<p>TODO</p>"},{"location":"api_reference/#qdselectormodel","title":"<code>QDSelectorModel</code>","text":"<p>TODO</p>"},{"location":"api_reference/#entropies","title":"<code>Entropies</code>","text":"<p>TODO</p>"},{"location":"api_reference/#scikit-learn-symbols","title":"scikit-learn symbols","text":""},{"location":"api_reference/#qdscreen","title":"<code>QDScreen</code>","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#064-bugfixes","title":"0.6.4 - Bugfixes","text":"<ul> <li>Replaced usage of deprecated <code>scipy_mode</code>. Fixed  #39</li> <li>Fixed <code>ValueError: invalid literal for int() with base 10</code> in <code>predict_qd</code>. Fixed #40</li> <li>Added input validators to raise human-readable error messages when the input is not correct. Fixes #37</li> <li>Fixed <code>AttributeError: module 'numpy' has no attribute 'object'.</code>. Fixes #38</li> </ul>"},{"location":"changelog/#063-bugfixes","title":"0.6.3 - Bugfixes","text":"<ul> <li>Fixed <code>ValueError</code> with recent versions of <code>SciPy</code>, due to usage of sparse arrays with object dtype. Fixes #31</li> <li>Fixed <code>IndexError</code> when <code>NaN</code> values are present in the dataframe. Fixes #28 </li> </ul>"},{"location":"changelog/#062-warning-filter","title":"0.6.2 - Warning filter","text":"<ul> <li>Now filtering <code>UserWarning</code> in <code>fit_selector_model</code> even in the sklearn adapter. Fixes #20 </li> </ul>"},{"location":"changelog/#061-minor-changes","title":"0.6.1 - Minor changes","text":"<ul> <li>Now filtering <code>UserWarning</code> in <code>fit_selector_model</code>. See #20 </li> <li>New build system: now using <code>virtualenv</code> instead of <code>conda</code> in <code>nox</code> sessions. Fixes #23</li> <li>New project layout to avoid bug with <code>xunitparser</code>. Fixes #18</li> </ul>"},{"location":"changelog/#060-sklearn-api-renames","title":"0.6.0 - sklearn api renames","text":"<ul> <li> <p>Migrated CI/CD from Travis to Github Actions + <code>nox</code>.</p> </li> <li> <p><code>selector_skl</code> module renamed <code>sklearn</code> and <code>QDSSelector</code> renamed <code>QDScreen</code>. Fixes #16</p> </li> </ul>"},{"location":"changelog/#050-first-public-working-release","title":"0.5.0 - First public working release","text":"<p>Initial release with:</p> <ul> <li>A main method <code>qd_screen</code> to get the (adjacency matrix of) the quasi-deterministic-forest, a <code>QDForest</code> object with string representation of arcs (Fixes #8).</li> <li>Possibility to <code>keep_stats</code> so as to analyse the (conditional) entropies in order to define a \"good\" threshold. </li> <li>A method <code>&lt;QDForest&gt;.fit_selector_model(X)</code> to fit a <code>QDSelectorModel</code> feature selection model able to select relevant features and to predict missing ones. Fixes #7</li> <li>Support for both pandas dataframes and numpy arrays as input. Fixes #2</li> <li>A Scikit-learn compliant feature selector <code>QDSSelector</code>, providing the exact same functionality as above but compliant with scikit-learn <code>Pipeline</code>s. Fixes #1</li> </ul> <p>Non-functional:</p> <ul> <li>Travis continuous integration, generating documentation and deploying releases on PyPi</li> <li>A package level <code>__version__</code> attribute. Fixes #3</li> <li>Added <code>py.typed</code> for PEP561 compliance. Fixed #4</li> <li>Initial <code>setup.py</code> and <code>setup.cfg</code></li> </ul>"},{"location":"long_description/","title":"qdscreen","text":"<p>Remove redundancy in your categorical variables and increase your models performance.</p> <p> </p> <p> </p> <p><code>qdscreen</code> is a python implementation of the Quasi-determinism screening algorithm from T.Rahier's PhD thesis, 2018.</p> <p>The documentation for users is available here: https://python-qds.github.io/qdscreen/</p> <p>A readme for developers is available here: https://github.com/python-qds/qdscreen</p>"},{"location":"generated/gallery/","title":"Usage examples","text":""},{"location":"generated/gallery/#usage-examples","title":"Usage examples","text":"<p>These examples demonstrate how to use the library.</p> <p> Removing correlated variables </p> <p> Download all examples in Python source code: gallery_python.zip</p> <p> Download all examples in Jupyter notebooks: gallery_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/1_remove_correlated_vars_demo/","title":"Removing correlated variables","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/gallery/1_remove_correlated_vars_demo/#removing-correlated-variables","title":"Removing correlated variables","text":"<p>In this example we show how to remove correlated categorical variables.</p>"},{"location":"generated/gallery/1_remove_correlated_vars_demo/#1-strict-determinism","title":"1. Strict determinism","text":"<p>Let's consider the following dataset:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\n   'U': [\"a\", \"b\", \"d\", \"a\", \"b\", \"c\", \"a\", \"b\", \"d\", \"c\"],\n   'V': [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"c\"],\n   'W': [\"a\", \"b\", \"b\", \"a\", \"b\", \"b\", \"a\", \"b\", \"b\", \"b\"],\n   'X': [\"a\", \"a\", \"b\", \"b\", \"a\", \"c\", \"c\", \"a\", \"b\", \"c\"],\n   'Y': [\"b\", \"b\", \"c\", \"c\", \"b\", \"a\", \"a\", \"b\", \"c\", \"a\"],\n   'Z': [\"a\", \"a\", \"b\", \"a\", \"a\", \"b\", \"b\", \"a\", \"a\", \"b\"]\n})\nprint(\"Columns in df: %s\" % list(df.columns))\ndf\n</code></pre> <p>Out:</p> <pre><code>Columns in df: ['U', 'V', 'W', 'X', 'Y', 'Z']\n</code></pre> U V W X Y Z 0 a a a a b a 1 b b b a b a 2 d c b b c b 3 a a a b c a 4 b b b a b a 5 c c b c a b 6 a a a c a b 7 b b b a b a 8 d c b b c a 9 c c b c a b <p>We can detect correlated categorical variables (functional dependencies):</p> <pre><code>from qdscreen import qd_screen\n\n# detect strict deterministic relationships\nqd_forest = qd_screen(df)\nprint(qd_forest)\n</code></pre> <p>Out:</p> <pre><code>/home/runner/work/qdscreen/qdscreen/.nox/publish-3-9/lib/python3.9/site-packages/pkg_resources/__init__.py:2804: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('mpl_toolkits')`.\nImplementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages\n  declare_namespace(pkg)\n/home/runner/work/qdscreen/qdscreen/.nox/publish-3-9/lib/python3.9/site-packages/sklearn/utils/multiclass.py:14: DeprecationWarning: Please use `spmatrix` from the `scipy.sparse` namespace, the `scipy.sparse.base` namespace is deprecated.\n  from scipy.sparse.base import spmatrix\n/home/runner/work/qdscreen/qdscreen/.nox/publish-3-9/lib/python3.9/site-packages/sklearn/utils/optimize.py:18: DeprecationWarning: Please use `line_search_wolfe2` from the `scipy.optimize` namespace, the `scipy.optimize.linesearch` namespace is deprecated.\n  from scipy.optimize.linesearch import line_search_wolfe2, line_search_wolfe1\n/home/runner/work/qdscreen/qdscreen/.nox/publish-3-9/lib/python3.9/site-packages/sklearn/utils/optimize.py:18: DeprecationWarning: Please use `line_search_wolfe1` from the `scipy.optimize` namespace, the `scipy.optimize.linesearch` namespace is deprecated.\n  from scipy.optimize.linesearch import line_search_wolfe2, line_search_wolfe1\nQDForest (6 vars):\n - 3 roots (1+2*): U*, X*, Z\n - 3 other nodes: V, W, Y\n\nU\n\u2514\u2500 V\n   \u2514\u2500 W\n\nX\n\u2514\u2500 Y\n</code></pre> <p>So with only features <code>U</code>, and <code>X</code> we should be able to predict <code>V</code>, <code>W</code>, and <code>Y</code>. <code>Z</code> is a root but has no children so it does not help.</p> <p>We can create a feature selection model from this deterministic forest object:</p> <pre><code>feat_selector = qd_forest.fit_selector_model(df)\nfeat_selector\n</code></pre> <p>Out:</p> <pre><code>&lt;qdscreen.selector.QDSelectorModel object at 0x7fc96ef42700&gt;\n</code></pre> <p>This model can be used to preprocess the dataset before a learning task:</p> <pre><code>only_important_features_df = feat_selector.remove_qd(df)\nonly_important_features_df\n</code></pre> U X Z 0 a a a 1 b a a 2 d b b 3 a b a 4 b a a 5 c c b 6 a c b 7 b a a 8 d b a 9 c c b <p>It can also be used to restore the dependent columns from the remaining ones:</p> <pre><code>restored_full_df = feat_selector.predict_qd(only_important_features_df)\nrestored_full_df\n</code></pre> U X Z V W Y 0 a a a a a b 1 b a a b b b 2 d b b c b c 3 a b a a a c 4 b a a b b b 5 c c b c b a 6 a c b a a a 7 b a a b b b 8 d b a c b c 9 c c b c b a <p>Note that the order of columns differs from origin, but apart from this, the restored dataframe is the same as the original:</p> <pre><code>pd.testing.assert_frame_equal(df, restored_full_df[df.columns])\n</code></pre>"},{"location":"generated/gallery/1_remove_correlated_vars_demo/#2-quasi-determinism","title":"2. Quasi determinism","text":"<p>In the above example, we used the default settings for <code>qd_screen</code>. By default only deterministic relationships are detected, which means that only variables that can perfectly be predicted (without loss of information) from others in the dataset are removed.</p> <p>In real-world datasets, some noise can occur in the data, or some very rare cases might happen, that you may wish to discard. Let's first look at the strength of the various relationships thanks to <code>keep_stats=True</code>:</p> <pre><code># same than above, but this time remember the various indicators\nqd_forest = qd_screen(df, keep_stats=True)\n\n# display them\nprint(qd_forest.stats)\n</code></pre> <p>Out:</p> <pre><code>Statistics computed for dataset:\n   U  V  W  X  Y  Z\n0  a  a  a  a  b  a\n1  b  b  b  a  b  a\n...(10 rows)\n\nEntropies (H):\nU    1.970951\nV    1.570951\nW    0.881291\nX    1.570951\nY    1.570951\nZ    0.970951\ndtype: float64\n\nConditional entropies (Hcond = H(row|col)):\n          U         V         W         X         Y         Z\nU  0.000000  0.400000  1.089660  0.875489  0.875489  1.475489\nV  0.000000  0.000000  0.689660  0.875489  0.875489  1.200000\nW  0.000000  0.000000  0.000000  0.875489  0.875489  0.875489\nX  0.475489  0.875489  1.565148  0.000000  0.000000  0.875489\nY  0.475489  0.875489  1.565148  0.000000  0.000000  0.875489\nZ  0.475489  0.600000  0.965148  0.275489  0.275489  0.000000\n\nRelative conditional entropies (Hcond_rel = H(row|col)/H(row)):\n          U         V         W         X         Y         Z\nU  0.000000  0.202948  0.552860  0.444196  0.444196  0.748618\nV  0.000000  0.000000  0.439008  0.557299  0.557299  0.763869\nW  0.000000  0.000000  0.000000  0.993416  0.993416  0.993416\nX  0.302676  0.557299  0.996307  0.000000  0.000000  0.557299\nY  0.302676  0.557299  0.996307  0.000000  0.000000  0.557299\nZ  0.489715  0.617951  0.994024  0.283731  0.283731  0.000000\n</code></pre> <p>In the last row of the last table (relative conditional entropies) we see that variable <code>Z</code>'s entropies decreases drastically to reach 28% of its initial entropy, if <code>X</code> or <code>Y</code> is known. So if we use quasi-determinism with relative threshold of 29% <code>Z</code> would be eliminated.</p> <pre><code># detect quasi deterministic relationships\nqd_forest2 = qd_screen(df, relative_eps=0.29)\nprint(qd_forest2)\n</code></pre> <p>Out:</p> <pre><code>QDForest (6 vars):\n - 2 roots (0+2*): U*, X*\n - 4 other nodes: V, W, Y, Z\n\nU\n\u2514\u2500 V\n   \u2514\u2500 W\n\nX\n\u2514\u2500 Y\n\u2514\u2500 Z\n</code></pre> <p>This time <code>Z</code> is correctly determined as being predictible from <code>X</code>.</p> <p>equivalent nodes</p> <p><code>X</code> and <code>Y</code> are equivalent variables so each of them could be the parent of the other. To avoid cycles so that the result is still a forest (a set of trees), <code>X</code> was arbitrary selected as being the \"representative\" parent of all its equivalents, and <code>Z</code> is attached to this representative parent.</p> <p>Another, easier way to detect that setting a relative threshold to 29% would eliminate <code>Z</code> is to print the conditional entropies in increasing order:</p> <pre><code>ce_df = qd_forest.get_entropies_table(from_to=False, sort_by=\"rel_cond_entropy\")\nce_df.head(10)\n</code></pre> cond_entropy rel_cond_entropy arc U-&gt;V 0.000000 0.000000 U-&gt;W 0.000000 0.000000 V-&gt;W 0.000000 0.000000 Y-&gt;X 0.000000 0.000000 X-&gt;Y 0.000000 0.000000 V-&gt;U 0.400000 0.202948 Y-&gt;Z 0.275489 0.283731 X-&gt;Z 0.275489 0.283731 U-&gt;X 0.475489 0.302676 U-&gt;Y 0.475489 0.302676 <p>Or to use the helper plot function:</p> <pre><code>qd_forest.plot_increasing_entropies()\n</code></pre> <p></p>"},{"location":"generated/gallery/1_remove_correlated_vars_demo/#3-integrating-with-scikit-learn","title":"3. Integrating with scikit-learn","text":"<p><code>scikit-learn</code> is one of the most popular machine learning frameworks in python. It comes with a concept of <code>Pipeline</code> allowing you to chain several operators to make a model. <code>qdscreen</code> provides a <code>QDScreen</code> class for easy integration. It works exactly like other feature selection models in scikit-learn (e.g. <code>VarianceThreshold</code>):</p> <pre><code>from qdscreen.sklearn import QDScreen\n\nX = [[0, 2, 0, 3],\n     [0, 1, 4, 3],\n     [0, 1, 1, 3]]\n\nselector = QDScreen()\nXsel = selector.fit_transform(X)\nXsel\n</code></pre> <p>Out:</p> <pre><code>array([[0],\n       [4],\n       [1]])\n</code></pre> <pre><code>selector.inverse_transform(Xsel)\n</code></pre> <p>Out:</p> <pre><code>array([[0, 2, 0, 3],\n       [0, 1, 4, 3],\n       [0, 1, 1, 3]])\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.536 seconds)</p> <p> Download Python source code: 1_remove_correlated_vars_demo.py</p> <p> Download Jupyter notebook: 1_remove_correlated_vars_demo.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/gallery/mg_execution_times/","title":"Computation times","text":"<p>00:01.536 total execution time for generated_gallery files:</p> <p>+----------------------------------------------------------------------------------------------------------------------+-----------+--------+ | 1_remove_correlated_vars_demo (docs/examples/1_remove_correlated_vars_demo.py) | 00:01.536 | 0.0 MB | +----------------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"}]}